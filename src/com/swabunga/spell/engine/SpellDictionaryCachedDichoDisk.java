package com.swabunga.spell.engine;import java.io.*;import java.util.*;/** * Yet another <code>SpellDictionary</code> this one is based on Damien Guillaume's * Diskbased dictionary but adds a cache to try to improve abit on performance. * * @author Robert Gustavsson * @version 0.01 */public class SpellDictionaryCachedDichoDisk extends SpellDictionaryDichoDisk {        // Only used for testing to measure the effectiveness of the cache.    static public int hits=0;    static public int codes=0;    public static final String PRE_CACHE_FILE_EXT=".pre";    private static int  MAX_CACHED=10000;    private HashMap     suggestionCache=new HashMap(MAX_CACHED);    private String      preCacheFileName;    /**     * Dictionary Convienence Constructor.     */    public SpellDictionaryCachedDichoDisk(File wordList)                                     throws FileNotFoundException, IOException {        super((File) wordList);        loadPreCache(wordList);    }        /**     * Dictionary Convienence Constructor.     */    public SpellDictionaryCachedDichoDisk(File wordList, String encoding)                                     throws FileNotFoundException, IOException {        super(wordList, encoding);        loadPreCache(wordList);    }    /**     * Dictionary constructor that uses an aspell phonetic file to     * build the transformation table.     */    public SpellDictionaryCachedDichoDisk(File wordList, File phonetic)                                     throws FileNotFoundException, IOException {        super(wordList, phonetic);        loadPreCache(wordList);    }    /**     * Dictionary constructor that uses an aspell phonetic file to     * build the transformation table.     */    public SpellDictionaryCachedDichoDisk(File wordList, File phonetic, String encoding)                                     throws FileNotFoundException, IOException {        super(wordList, phonetic, encoding);        loadPreCache(wordList);    }    /**     * Add a word permanantly to the dictionary (and the dictionary file).     * <i>not implemented !</i>     */    public void addWord(String word) {        System.err.println("error: addWord is not implemented for SpellDictionaryDichoDisk");    }    /**     * Clears the cache.     */    public void clearCache(){        suggestionCache.clear();    }    /**     * Returns a list of strings (words) for the code.     */    public List getWords(String code) {        List list;        codes++;        if(suggestionCache.containsKey(code)){            hits++;            list=getCachedList(code);            return list;        }        list=super.getWords(code);        addToCache(code,list);                return list;    }    /**     * This method returns the cached suggestionlist and also moves the code to     * the top of the codeRefQueue to indicate this code has resentlly been     * referenced.     */    private List getCachedList(String code){        CacheObject obj=(CacheObject)suggestionCache.get(code);        obj.setRefTime();        return obj.getSuggestionList();    }    /**     * Adds a code and it's suggestion list to the cache.     */    private void addToCache(String code, List l){        String c;        Iterator it;        CacheObject obj;        if(suggestionCache.size()>=MAX_CACHED){            it=suggestionCache.values().iterator();            while(it.hasNext()){                if(((CacheObject)it.next()).getRefTime()==0){                    it.remove();                    return;                }            }            it.remove();        }                suggestionCache.put(code,new CacheObject(l));    }    /**     * Load the cache from file. The cach file has the same name as the      * dico file with the .pre extension added.     */    private void loadPreCache(File dicoFile)throws IOException{        String  code;        List    suggestions;        HashMap map;        long    size;        preCacheFileName=dicoFile.getPath()+PRE_CACHE_FILE_EXT;        File preFile=new File(preCacheFileName);        if(!preFile.exists()){            System.out.println("No precache file");            return;        }        System.out.println("Precaching...");        ObjectInputStream in=new ObjectInputStream(new FileInputStream(preFile));        try{            size=in.readLong();            for(int i=0;i<size;i++){                code=(String)in.readObject();                suggestions=(List)in.readObject();                suggestionCache.put(code,new CacheObject(suggestions));            }            in.close();        }catch(ClassNotFoundException ex){            System.out.println(ex.getMessage());        }catch(IOException ex){            System.out.println("EndOfFile");        }    }    /**     * Saves the current cache to file.     */    public void saveCache() throws IOException{        String  code;        if(preCacheFileName==null){            System.out.println("NULL");            return;        }        File preFile=new File(preCacheFileName);        System.out.println("Saving cache...");        ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(preFile));        Iterator it=suggestionCache.keySet().iterator();        out.writeLong(suggestionCache.size());        while(it.hasNext()){            code=(String)it.next();            out.writeObject(code);            out.writeObject(((CacheObject)suggestionCache.get(code)).getSuggestionList());        }        out.close();    }    // INNER CLASSES    // ------------------------------------------------------------------------    private class CacheObject implements Serializable{            private List    suggestions=null;        private long    refTime=0;        public CacheObject(List list){            this.suggestions=list;        }                public List getSuggestionList(){            return suggestions;        }        public void setRefTime(){            refTime=System.currentTimeMillis();        }        public long getRefTime(){            return refTime;        }    }}